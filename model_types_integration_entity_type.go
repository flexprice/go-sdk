/*
FlexPrice API

FlexPrice API Service

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package flexprice

import (
	"encoding/json"
	"fmt"
)

// TypesIntegrationEntityType the model 'TypesIntegrationEntityType'
type TypesIntegrationEntityType string

// List of types.IntegrationEntityType
const (
	TYPESINTEGRATIONENTITYTYPE_IntegrationEntityTypeCustomer TypesIntegrationEntityType = "customer"
	TYPESINTEGRATIONENTITYTYPE_IntegrationEntityTypePlan TypesIntegrationEntityType = "plan"
	TYPESINTEGRATIONENTITYTYPE_IntegrationEntityTypeInvoice TypesIntegrationEntityType = "invoice"
	TYPESINTEGRATIONENTITYTYPE_IntegrationEntityTypeSubscription TypesIntegrationEntityType = "subscription"
	TYPESINTEGRATIONENTITYTYPE_IntegrationEntityTypePayment TypesIntegrationEntityType = "payment"
	TYPESINTEGRATIONENTITYTYPE_IntegrationEntityTypeCreditNote TypesIntegrationEntityType = "credit_note"
	TYPESINTEGRATIONENTITYTYPE_IntegrationEntityTypeAddon TypesIntegrationEntityType = "addon"
	TYPESINTEGRATIONENTITYTYPE_IntegrationEntityTypeItem TypesIntegrationEntityType = "item"
	TYPESINTEGRATIONENTITYTYPE_IntegrationEntityTypeItemPrice TypesIntegrationEntityType = "item_price"
	TYPESINTEGRATIONENTITYTYPE_IntegrationEntityTypePrice TypesIntegrationEntityType = "price"
)

// All allowed values of TypesIntegrationEntityType enum
var AllowedTypesIntegrationEntityTypeEnumValues = []TypesIntegrationEntityType{
	"customer",
	"plan",
	"invoice",
	"subscription",
	"payment",
	"credit_note",
	"addon",
	"item",
	"item_price",
	"price",
}

func (v *TypesIntegrationEntityType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := TypesIntegrationEntityType(value)
	for _, existing := range AllowedTypesIntegrationEntityTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid TypesIntegrationEntityType", value)
}

// NewTypesIntegrationEntityTypeFromValue returns a pointer to a valid TypesIntegrationEntityType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewTypesIntegrationEntityTypeFromValue(v string) (*TypesIntegrationEntityType, error) {
	ev := TypesIntegrationEntityType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for TypesIntegrationEntityType: valid values are %v", v, AllowedTypesIntegrationEntityTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v TypesIntegrationEntityType) IsValid() bool {
	for _, existing := range AllowedTypesIntegrationEntityTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to types.IntegrationEntityType value
func (v TypesIntegrationEntityType) Ptr() *TypesIntegrationEntityType {
	return &v
}

type NullableTypesIntegrationEntityType struct {
	value *TypesIntegrationEntityType
	isSet bool
}

func (v NullableTypesIntegrationEntityType) Get() *TypesIntegrationEntityType {
	return v.value
}

func (v *NullableTypesIntegrationEntityType) Set(val *TypesIntegrationEntityType) {
	v.value = val
	v.isSet = true
}

func (v NullableTypesIntegrationEntityType) IsSet() bool {
	return v.isSet
}

func (v *NullableTypesIntegrationEntityType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTypesIntegrationEntityType(val *TypesIntegrationEntityType) *NullableTypesIntegrationEntityType {
	return &NullableTypesIntegrationEntityType{value: val, isSet: true}
}

func (v NullableTypesIntegrationEntityType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTypesIntegrationEntityType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

